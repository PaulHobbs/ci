package domain

import (
	"time"

	"github.com/example/turboci-lite/pkg/id"
)

// StageRunner represents a registered stage runner.
type StageRunner struct {
	ID             string            // Unique runner instance ID (from runner)
	RegistrationID string            // Registration ID (generated by orchestrator)
	RunnerType     string            // Type of stages this runner handles
	Address        string            // gRPC endpoint address
	SupportedModes []ExecutionMode   // Supported execution modes
	MaxConcurrent  int               // Maximum concurrent executions (0 = unlimited)
	CurrentLoad    int               // Current number of active executions
	Metadata       map[string]string // Optional metadata
	RegisteredAt   time.Time         // When registered
	LastHeartbeat  time.Time         // Last heartbeat time
	ExpiresAt      time.Time         // When registration expires
}

// NewStageRunner creates a new stage runner registration.
func NewStageRunner(runnerID, runnerType, address string, modes []ExecutionMode, maxConcurrent int, ttl time.Duration) *StageRunner {
	now := time.Now().UTC()
	return &StageRunner{
		ID:             runnerID,
		RegistrationID: id.Generate(),
		RunnerType:     runnerType,
		Address:        address,
		SupportedModes: modes,
		MaxConcurrent:  maxConcurrent,
		CurrentLoad:    0,
		Metadata:       make(map[string]string),
		RegisteredAt:   now,
		LastHeartbeat:  now,
		ExpiresAt:      now.Add(ttl),
	}
}

// IsExpired returns true if the registration has expired.
func (r *StageRunner) IsExpired() bool {
	return time.Now().UTC().After(r.ExpiresAt)
}

// HasCapacity returns true if the runner can accept more work.
func (r *StageRunner) HasCapacity() bool {
	return r.MaxConcurrent == 0 || r.CurrentLoad < r.MaxConcurrent
}

// SupportsMode returns true if the runner supports the given execution mode.
func (r *StageRunner) SupportsMode(mode ExecutionMode) bool {
	for _, m := range r.SupportedModes {
		if m == mode {
			return true
		}
	}
	return false
}

// IncrementLoad increases the current load counter.
func (r *StageRunner) IncrementLoad() {
	r.CurrentLoad++
}

// DecrementLoad decreases the current load counter.
func (r *StageRunner) DecrementLoad() {
	if r.CurrentLoad > 0 {
		r.CurrentLoad--
	}
}

// RefreshHeartbeat updates the heartbeat time and extends expiry.
func (r *StageRunner) RefreshHeartbeat(ttl time.Duration) {
	now := time.Now().UTC()
	r.LastHeartbeat = now
	r.ExpiresAt = now.Add(ttl)
}

// AvailableCapacity returns the number of additional executions this runner can handle.
// Returns -1 if unlimited.
func (r *StageRunner) AvailableCapacity() int {
	if r.MaxConcurrent == 0 {
		return -1 // Unlimited
	}
	available := r.MaxConcurrent - r.CurrentLoad
	if available < 0 {
		return 0
	}
	return available
}
